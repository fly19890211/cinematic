{"version":3,"sources":["meteor://ðŸ’»app/cinematic.js"],"names":[],"mappings":"cAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C","file":"/cinematic.js","sourcesContent":["/*\n * TODO\n * - account for missing sort params\n * - Unused data: popularity, country, language, awards\n * - auto rename files\n * - limit, possibly paginate\n * - file browser\n * - TV Shows\n * - Filter by Director\n * - Ambiguous search\n\n\n parse intel genres\n scroll anywhere\n\n */\n\n\nvar settings = {\n  DEFAULT_PATH: '/Users/',\n  valid_types: ['.avi', '.flv', '.mp4', '.m4v', '.mov', '.ogg', '.ogv', '.vob', '.wmv'],\n  sort_types: [\"Alphabetical\", \"Popularity\", \"Release Date\", \"Runtime\", \"Random\" /*, \"Ratings\" */ ],\n  cache: 3600, // seconds; 604800 = 7 days\n  overview_length: 'short', // \"short\", \"full\" - from omdb\n\n  // http://docs.themoviedb.apiary.io/ config\n  key: '9d2bff12ed955c7f1f74b83187f188ae',\n  base_url: \"http://image.tmdb.org/t/p/\",\n  secure_base_url: \"https://image.tmdb.org/t/p/\",\n  genre_url: \"http://api.themoviedb.org/3/genre/movie/list\",\n  backdrop_size: 'w1280', // \"w300\", \"w780\", \"w1280\", \"original\"\n  poster_size: 'w185', //\"w92\", \"w154\", \"w185\", \"w342\", \"w500\", \"w780\", \"original\",\n\n  // app-specific -- affects how app is run and may affect performance\n  max_connections: 5, // max number of simultaneous\n  parse_method: \"parse\", // \"regex\", \"parse\"\n  rating_delay: 5000, // milli-seconds of rating rotate interval; 5000 = 5 seconds\n  retry_delay: 3000, // milli-seconds delay of retrying failed api requests to alieviate thousands of simultaneous requests;\n  recurse_level: 1, // how many directory levels to recursively search. higher is further down the rabbit hole.\n  ignore_list: ['sample', 'etrg'] // a lowercase list of movie titles to ignore\n}\n\n// define db collections\nLog = new Mongo.Collection(\"log\");\nState = new Mongo.Collection(\"state\");\nRecent = new Mongo.Collection(\"recent\");\nWatched = new Mongo.Collection(\"watched\");\nGenres = new Mongo.Collection(\"genres\");\nMovies = new Mongo.Collection(\"movies\");\nMovieCache = new Mongo.Collection(\"movieCache\");\n\n\n\n/*\n * CLIENT\n */\n\n if (Meteor.isClient) {\n  var ratingTimer;\n  var totalRatings;\n  \n  // observe db collections\n  Meteor.subscribe(\"log\");\n  Meteor.subscribe(\"state\");\n  Meteor.subscribe(\"recent\");\n  Meteor.subscribe(\"watched\");\n  Meteor.subscribe(\"genres\");\n  Meteor.subscribe(\"movies\");\n  Meteor.subscribe(\"movieCache\");\n\n  // third-party\n  NProgress.configure({ trickleRate: 0.01, trickleSpeed: 1400 });\n  $(function () {\n    $('[data-toggle=\"tooltip\"]').tooltip();\n  });\n\n  Template.registerHelper('equals',\n      function(v1, v2) {\n          return (v1 === v2);\n      }\n  );\n  Template.registerHelper('gt',\n      function(v1, v2) {\n          return (v1 > v2);\n      }\n  );\n\n\n  // define nav helpers\n  Template.body.helpers({\n    page: function () {\n      return Session.get('currentPage');\n    }\n  });\n  Template.navigation.helpers({\n    page: function () {\n      return Session.get('currentPage');\n    },\n    genres: function () {\n      return Genres.find({'items': {$exists : true }},{ sort: { name: 1 }}).fetch();\n    },\n    movieCount: function () {\n      return Movies.find().count();\n    },\n    recentCount: function () {\n      return Recent.find().count();\n    },\n    watchedCount: function () {\n      return Watched.find().count();\n    },\n  });\n\n  // define loading indicatior\n  Template.header.helpers({\n    loading: function () {\n      var state = State.findOne({_id: \"0\"});\n      // invert percentage (0 is done, 100% complete, false, off; 100 is 0% complete)\n      var loaded = state && (100-state.loading);\n      setLoaded(loaded/100);\n      return loaded;\n    }\n  });\n\n  // define details helpers\n  Template.details.helpers({\n    rating: function () {\n      return Session.get('activeRating');\n    },\n    settings: function () {\n      return settings;\n    },\n    movie: function () {\n      var movie = Movies.findOne({_id: Session.get('currentMovie')});\n      if(movie){\n        movie.ratings.map(function(o, i) {\n          movie.ratings[i].index = i;\n          if(i == movie.ratings.length - 1) {\n            movie.ratings[i].indexPlus = 0;\n          } else {\n            movie.ratings[i].indexPlus = i + 1;\n          }\n        });\n      }\n      return movie;\n    },\n    currentTrailer: function () {\n      return Session.get('currentTrailer');\n    }\n  });\n\n  // define movies helpers\n  Template.movies.helpers({\n    movies: function () {\n      var movies = Movies.find(Session.get('movieQuery'), Session.get('movieSort')).fetch();\n      var index = 0;\n      movies.map(function(o, i) {\n        movies[i].index = index++;\n      })\n      return movies;\n    }\n  });\n\n  // define path helpers\n  Template.path.helpers({\n    path: function () {\n      var state = State.findOne({_id: \"0\"});\n      return state && state.path;\n    }\n  });\n\n  // sort helpers\n  Template.sort.helpers({\n    showSort: function () {\n      var currentSort = Session.get('currentSort');\n      return currentSort != 'Recent';\n    },\n    sort: function(){\n        return settings.sort_types;\n    },\n    currentSort: function () {\n      return Session.get('currentSort');\n    }\n  });\n\n  Template.body.events({\n    \"click #refresh\": function (event) {\n      broadcast('Cinematic: Resetting client...');\n      resetClient();\n      Meteor.call('reset');\n    }\n  });\n\n  // sort event\n  Template.sort.events({\n      \"change #sort\": function (event, template) {\n        var sort = $(event.currentTarget).val();\n        Session.set('currentSort', sort);\n        // warning, magic numbers below, indexs reference sort types above\n        if(sort == settings.sort_types[0]) { // Alphabetical\n          Session.set('movieSort', { sort: { name: 1 }});\n        } else if (sort == settings.sort_types[1]) { // Popularity\n          Session.set('movieSort', { sort: { 'info.popularity': -1 }});\n        } else if (sort == settings.sort_types[2]) { // Release Date\n          Session.set('movieSort', { sort: { 'info.release_date': -1 }});\n        } else if (sort == settings.sort_types[3]) { // Runtime\n          Session.set('movieSort', { sort: { 'intel.Runtime': 1 }});\n        } else if (sort == settings.sort_types[4]) { // Random\n          Session.set('movieSort', { sort: { 'seed': 1 }});\n        } else if (sort == 'Ratings') { // inactive, should use avg ratings\n\n        }\n      },\n      \"click #random\": function (event) {\n        Meteor.call('updateRandom');\n      }\n  });\n\n  // handle page changes with filter\n  Template.navigation.events = {\n    \"click #links-panel li.link\": function (event) {\n      var page = Session.get('currentPage');\n      if(Session.get('currentSort') == 'Recent'){\n        resetSort();\n      }\n      var pid = String(event.currentTarget.dataset.id);\n      var currentPage = $(event.currentTarget).text();\n      Session.set('currentPage', currentPage);\n      // hide right panel\n      Session.set('currentMovie', 0);\n      var genre = Genres.findOne(pid);\n      if(genre) {\n        // genre page - All: alphabetical\n        Session.set('movieQuery', {_id: { $in: Genres.findOne(pid).items}});\n      } else if(currentPage == 'New') {\n        // browse Recently Released\n        Session.set('movieQuery', {});\n      }  else if(currentPage == 'Recent') {\n        // browse recently viewed: alphabetical  **** HAVENT FIGURED OUT SORTING\n        var recent = [];\n        _.map(Recent.find().fetch(), function(e){\n          recent.push(e._id);\n        });\n        Session.set('currentSort', 'Recent');\n        Session.set('movieQuery', {_id: { $in: recent }});\n        Session.set('movieSort', { sort: { 'recent_time': -1 }});\n      } else if(currentPage == 'Watched') {\n        // browse watched: order of watched\n        var watched = [];\n        _.map(Watched.find().fetch(), function(e){\n          watched.push(e._id);\n        });\n        Session.set('currentSort', 'Recent');\n        Session.set('movieQuery', {_id: { $in: watched}});\n        Session.set('movieSort', { sort: { 'watched_time': -1 }});\n      }  else {\n        // main page - All: alphabetical\n        Session.set('movieQuery', {});\n      }\n    }\n  }\n\n\n  Template.details.events = {\n    \"click #rating\" : function (event) {\n      // switch ratings\n      if(ratingTimer)\n        Meteor.clearInterval(ratingTimer);\n      ratingTimer = Meteor.setInterval(rotateRating, 4000);\n      rotateRating();\n    }, \n    \"click #open-link\": function (event) {\n      var url = event.currentTarget.dataset.src;\n      var mid = event.currentTarget.dataset.id;\n      Meteor.call('addWatched', mid);\n      Meteor.call('openFile', url);\n    },\n    \"click #trailer .trailer\" : function (event) {\n      // switch trailers\n      Session.set('currentTrailer', event.currentTarget.dataset.id);\n    }\n  }\n\n  // define movie events\n  Template.movies.events = {\n    // show right panel\n    \"click .movie-image\": function (event){\n      // switch current movie in details panel\n      var id = event.currentTarget.dataset.id;\n      var trailers = Movies.findOne({'_id': id}, {fields: {trailer: 1}});\n      var ratings = Movies.findOne({'_id': id}, {fields: {ratings: 1}}).ratings;\n      totalRatings = ratings.length;\n      // set initial trailer\n      var trailer = trailers && trailers.trailer && trailers.trailer[0] && trailers.trailer[0].key;\n      Session.set('currentTrailer', trailer);\n      // set current movie and add to recent\n      Session.set('currentMovie', id);\n      Meteor.call('addRecent', id);\n      // set timer to rotate ratings\n      if(ratingTimer)\n        Meteor.clearInterval(ratingTimer);\n      ratingTimer = Meteor.setInterval(rotateRating, 4000);\n    },\n    \"keyup .movie-image\": function (event){\n      var magnitude = 3; // $(\".keyboard-magnitude\").data('id'); // this should equal the number of movies per row\n      event.preventDefault();\n      if(event.which == 37){\n        // left\n        var currTab = parseInt($('.movie-image:focus').attr('tabIndex')) - 1;\n        $('.movie-image[tabIndex=\"'+currTab+'\"]').click();\n        $('.movie-image[tabIndex=\"'+currTab+'\"]').focus();\n      } else if(event.which == 39){\n        // right\n        var currTab = parseInt($('.movie-image:focus').attr('tabIndex')) + 1;\n        $('.movie-image[tabIndex=\"'+currTab+'\"]').click();\n        $('.movie-image[tabIndex=\"'+currTab+'\"]').focus();\n      // } else if(event.which == 38){\n      //   // up\n      //   var currTab = parseInt($('.movie-image:focus').attr('tabIndex')) - magnitude;\n      //   $('.movie-image[tabIndex=\"'+currTab+'\"]').click();\n      //   $('.movie-image[tabIndex=\"'+currTab+'\"]').focus();\n      // } else if(event.which == 40){\n      //   // down\n      //   var currTab = parseInt($('.movie-image:focus').attr('tabIndex')) + magnitude;\n      //   $('.movie-image[tabIndex=\"'+currTab+'\"]').click();\n      //   $('.movie-image[tabIndex=\"'+currTab+'\"]').focus();\n      }\n    }\n  }\n\n  // define path events\n  Template.path.events = {\n    \"keyup #path\": function (event){\n      if(event.which == 13){\n        // on <enter> set path\n        setPath();\n      }\n    },\n    \"click #search-refresh\": function (event) {\n      setPath();\n    }\n  }\n\n  // client-side methods\n\n  var setLoaded = function (percentage) {\n    NProgress.start();\n    NProgress.set(percentage);\n  }\n  var setPath = function () {\n    resetClient();\n    var _path = document.getElementById('path');\n    if(_path.value != ''){\n      var path = _path.value;\n      if (path.slice(-1) != '/'){\n        path = path + '/';\n      }\n    } else {\n      path = settings.DEFAULT_PATH;\n    }\n    Meteor.call('updatePath', path);\n  }\n\n  var resetSort = function () {\n    // default sort values\n    Session.set('currentSort', settings.sort_types[0]);\n    Session.set('movieSort', { sort: { name: 1 }});\n  }\n\n  var rotateRating = function () {\n    // broadcast(totalRatings); // !important! number of ratings sources < ------------------- MAGIC NUMBER HERE\n    var x =  Session.get('activeRating');\n    Session.set('activeRating',(x + 1 == totalRatings ? 0: x + 1));\n  }\n\n  // defaults\n  var resetClient = function () {\n    resetSort();\n    Session.set('activeRating', 0);\n    Session.set('currentMovie', 0);\n    Session.set('currentPage', 'Movies');\n    Session.set('movieQuery', {});\n  }\n  resetClient();\n} // end Meteor.isClient\n\n\n/*\n * SERVER\n */\n\nif (Meteor.isServer) {\n  // import npm packages\n  var open = Meteor.npmRequire('open');\n  var omdbApi = Meteor.npmRequire('omdb-client');\n  var movieInfo = Meteor.npmRequire('movie-info');\n  var movieTrailer = Meteor.npmRequire('movie-trailer');\n  var parseTorrentName = Meteor.npmRequire('parse-torrent-name');\n  \n  // define observable collections\n  Meteor.publish(\"log\", function () { return Log.find(); });\n  Meteor.publish(\"state\", function () { return State.find(); });\n  Meteor.publish(\"recent\", function () { return Recent.find(); });\n  Meteor.publish(\"watched\", function () { return Watched.find(); });\n  Meteor.publish(\"genres\", function () { return Genres.find(); });\n  Meteor.publish(\"movies\", function () { return Movies.find(); });\n  Meteor.publish(\"movieCache\", function () { return MovieCache.find(); });\n\n  // server globals\n  // startup functions\n  Meteor.startup(function () {\n    // setup db - optionally clear movies, log, and path\n    Log.remove({});\n    Movies.remove({});\n\n    // welcome message\n    broadcast('\\n----- Cinematic -----');\n\n    // set default path\n    var dir = Meteor.call('findMovieDir');\n\n    // set up state\n    var time = epoch();\n    var state = State.findOne({_id:\"0\"});\n    if (!state) {\n      var sid = State.insert({_id: '0', path: dir, cwd: process.env.PWD});\n    }\n\n    // grab genre list\n    if(settings.cache && state && state.cache_genre && time < state.cache_genre+settings.cache) {\n      broadcast('Cinematic: Loading cached genre list.');\n    } else {\n      broadcast('Cinematic: Updating genre cache.');\n      Meteor.call('updateGenres');\n    }\n\n    // initial update\n    Meteor.call('updatePath', dir);\n  }); // end startup\n\n  // number of concurrent api connections; currently doesn't distinguish between different api source limits\n  // total, number left to process, currently processing\n  var api_total = 0, api_queue = 0, api_current = 0;\n\n  // server-side methods\n  Meteor.methods({\n    addGenre: function (gid, mid, name) {\n      var id = String(gid);\n      var genre = Genres.findOne({\"_id\": id});\n      if(genre && name) {\n        Genres.update(id, { $set: {name: name}});\n      } else if(genre && mid) {\n        var items = genre.items || [];\n        items.push(mid);\n        Genres.update(id, { $set: {items: items}});\n      } else if(name){\n        Genres.insert({_id: id, id: gid, name: name});\n      } else if (mid){\n        Genres.insert({_id: id, id: gid, name: name, items: [mid]});\n      }\n    },\n    addRecent: function (mid) {\n      var time = epoch();\n      Recent.upsert({ '_id': mid }, {'time': time});\n      Movies.update({'_id': mid}, {$set: {'recent_time': time}})\n    },\n    addWatched: function (mid) {\n      var time = epoch();\n      Watched.upsert({ '_id': mid }, {'time': time});\n      Movies.update({'_id': mid}, {$set: {'watched_time': time}})\n    },\n    cacheMovies: function () {\n      var movies = Movies.find();\n      var time = epoch();\n      movies.forEach(function(movie){\n        movie.cache_date = epoch();\n        MovieCache.upsert({'_id': movie.path+movie.file}, {cache_date: time, movie: movie});\n      });\n      State.update(\"0\", {$set: {cache_movies: time}});\n    },\n    cacheMovie: function (file) {\n      var mov = Movies.findOne({'file': file});\n      mov.cache_date = epoch();\n      // only cache if it loaded properly\n      if(mov && mov.intel.Title && mov.info.title){\n        MovieCache.insert(mov);\n      }\n    },\n    findMovieDir: function(){\n      var home = process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];\n      if(home.slice(-1) != '/'){\n        home = home + '/';\n      }\n      var dir = home;\n      var files = fs.readdirSync(home);\n      files.forEach(function(file, i){\n        var stats = fs.lstatSync(home+file);\n        if(stats.isDirectory() && (file.toLowerCase().indexOf('movies') != -1 || file.toLowerCase().indexOf('videos') != -1) ) {\n          dir = home+file+'/';\n        }\n      });\n      broadcast('Cinematic: Using ' + dir + ' as movie directory');\n      return dir;\n    },\n    getIntel: function(mid, name, year) {\n\n      // updates to gather\n      var jobs = [\n        'updateIntel',\n        'updateInfo',\n        'updateTrailer'\n      ];\n      _.map(jobs, function(job){\n        api_queue += 1;\n        api_total += 1;\n        Meteor.call('queueIt', job, mid, name, year, function(err, res) {\n          if(err)\n            broadcast('Cinematic/getIntel: ' + err);\n        });\n      });\n    },\n    openFile: function (file) {\n      broadcast('Cinematic: Opening ' + file);\n      open('file://' + file);\n    },\n    populateMovies: function (dirPath, recurse_level) {\n      try {\n        // start loading bar\n        State.update(\"0\", {$set: {loading: 100}});\n\n        // read from filesystem\n        var files = fs.readdirSync(dirPath);\n        var time = epoch();\n        files.forEach(function(file, i){\n          var ex = path.extname(file);\n          if (ex && _.contains(settings.valid_types, ex)) {\n            // found a movie!\n            // this is where the magic happens\n            if(settings.parse_method == \"regex\") {\n              var regex = /^(.*?)(?:\\[? ([\\d]{4})?\\]?|\\(?([\\d]{4})?\\)?)$/g;\n              var match = regex.exec(path.basename(file, ex));\n              var name = year = null;\n              if(match){\n                name = unescape(match[1]);\n                if(match.length > 1 && !isNaN(parseFloat(match[3])) && isFinite(match[3])){\n                  year = match[3];\n                }\n              }\n            } else {\n              var fileName = file.substr(0, file.length-ex.length);\n              var parsedName = parseTorrentName(file.substr(0, file.length-ex.length));\n              var name = (parsedName.title) ? parsedName.title : null;\n              var year = (parsedName.year) ? parsedName.year : null;\n            }\n\n            if(name && !_.contains(settings.ignore_list, name.toLowerCase())){\n              // cache handling\n              var hash = dirPath+file;\n              var movc = MovieCache.findOne({'_id': hash});\n              if(movc && settings.cache && movc.movie && time < movc.cache_date+settings.cache){\n                // cached\n                broadcast('Cinematic: Loading cached movie ' + name);\n                var mid = movc.movie._id;\n                Movies.insert(movc.movie);\n                _.each(movc.movie.info.genre_ids, function (e, i) {\n                  Meteor.call('addGenre', e, mid, null);\n                });\n              } else {\n                //not cached\n                // add item to collection\n                var mid = Movies.insert({\n                  ext: ex,\n                  file: file,\n                  name: name,\n                  path: dirPath,\n                  year: year,\n                  ratings: [],\n                  trailer: null,\n                  seed: Math.random(),\n                  recent_time: null,\n                  watched_time: null,\n                  info: {\n                    adult: false,\n                    backdrop: null,\n                    backdrop_path: null,\n                    genre_ids: [],\n                    imdb_id: null,\n                    original_title: null,\n                    overview: null,\n                    popularity: null,\n                    poster_path: null,\n                    release_date: year,\n                    tagline: null,\n                    title: null,\n                    vote_average: null\n                  },\n                  intel: {\n                    Actors: null,\n                    Awards: null,\n                    Country: null,\n                    Director: null,\n                    Genre: null,\n                    Language: null,\n                    Metascore: null,\n                    Plot: null,\n                    Poster: null,\n                    Rated: null,\n                    Released: null,\n                    Runtime: null,\n                    Title: null,\n                    Type: null,\n                    Writer: null,\n                    Year: null,\n                    imdbID: null,\n                    imdbRating: null\n                  },\n                  // combined info\n                  imdb_id: null,\n                  plot: null,\n                  poster: null,\n                  release_date: year,\n                  title: name,\n                });\n                // make api calls to gather info\n                Meteor.call('getIntel', mid, name, year);\n              }\n            }\n          } else if (recurse_level < settings.recurse_level) {\n            // ok let's try recursing, were avoiding as many fs calls as possible\n            // which is why i didn't call it in the condition above\n            // first, is this a directory?\n            fs.lstat(dirPath+file, Meteor.bindEnvironment(function(err, stats) {\n              if(err){\n                broadcast(name + ': ' + err);\n                return false;\n              }\n              if(stats.isDirectory()) {\n                Meteor.call('populateMovies', dirPath + file + '/', recurse_level+1);\n              }\n            }));\n          }\n          var state = State.findOne({_id: \"0\"});\n          // invert percentage (0 is done, 100% complete, false, off; 100 is 0% complete)\n          var loaded = state && (100-state.loading);\n        }); // end file scan forEach\n        if(api_queue === 0){\n          State.update(\"0\", {$set: {loading: 0}});\n        }\n      } catch (e) {\n        broadcast('Error populating movies. ' + e.name + ' ' + e.message);\n      }\n    },\n    updatePath: function (path) {\n      try {\n        if(fs.statSync(path).isDirectory()) {\n          Movies.remove({});\n          State.update(\"0\", {$set: {path: path}});\n        } else {\n          throw new Error(\"Error: Path is not a directory.\");\n        }\n        Meteor.call('populateMovies', path, 0);\n      } catch (e) {\n        broadcast('Error getting path. ' + e.name + ' ' + e.message);\n      }\n    },\n    updateGenres: function () {\n      Genres.remove({});\n      HTTP.call(\"GET\", settings.genre_url+'?api_key='+settings.key,\n                function (err, res) {\n                  if (err) {\n                    broadcast('Cinematic/updateGenres: ' + err);\n                  } else if (res.data.genres){\n                    res.data.genres.forEach(function(genre){\n                      Meteor.call('addGenre', genre.id, null, genre.name);\n                    });\n                    State.update(\"0\", {$set: {cache_genre: epoch()}});\n                  } else {\n                    broadcast('Cinematic: Error getting genre list.')\n                  }\n                });\n    },\n    updateIntel: function (mid, name, year) {\n      omdbApi.get({title: name, plot: (settings.overview_length === 'short') ? 'short' : 'full'}, Meteor.bindEnvironment(function (err, res){\n        Meteor.call('queueDone', 'updateIntel');\n        if(err){\n          broadcast(name + ': ' + err);\n          return false;\n        }\n        // strip runtime characters\n        res.Runtime = res.Runtime.replace(/\\D/g,'');\n        // toss any \"N/A\" response\n        for (var key in res) {\n          if(res[key] == \"N/A\"){\n            res[key] = null;\n          }\n        }\n        // lets parse this shit proper\n        var mov = Movies.findOne({_id: mid});\n        if(res.imdbRating){\n          mov.ratings.push({name: 'IMDB RATING', score: parseFloat(res.imdbRating), \n            count: Array.apply(null, Array(Math.round(res.imdbRating))).map(function(){return {};})});\n        }\n        if(res.Metascore){\n          mov.ratings.push({name: 'METASCORE RATING', score: res.Metascore/10,\n            count: Array.apply(null, Array(Math.round(res.Metascore/10))).map(function(){return {};})});\n        }\n        mov.imdb_id = res.imdbID;\n        mov.plot = res.Plot\n        mov.poster = res.Poster;\n        mov.release_date = Date.parse(res.Released);\n        mov.title = res.Title;\n        if(!mov.poster){\n          mov.poster = res.Poster;\n        }\n        if(!mov.year){\n          mov.year = res.Year;\n        }\n        mov.intel = res;\n        Movies.update(mid, mov);\n      }));\n    },\n    updateInfo: function (mid, name, year) {\n      movieInfo(name, year, Meteor.bindEnvironment(function (err, res){\n        Meteor.call('queueDone', 'updateInfo');\n        if(err){\n          broadcast(name + ': ' + err);\n          return false;\n        }\n        _.each(res.genre_ids, function (e, i) {\n          Meteor.call('addGenre', e, mid, null);\n        });\n        // lets parse this shit proper\n        var mov = Movies.findOne({_id: mid});\n        res.backdrop = settings.secure_base_url + settings.backdrop_size + res.backdrop_path;\n        if(res.vote_average) {\n          mov.ratings.push({name: 'TMDB RATING', score: parseFloat(res.vote_average),\n            count: Array.apply(null, Array(Math.round(res.vote_average))).map(function(){return {};})});\n        }\n        mov.imdb_id = res.imdb_id;\n        mov.poster = settings.secure_base_url + settings.poster_size + res.poster_path;\n        mov.title = res.title;\n        if(!mov.plot) {\n          mov.plot = res.overview;\n        }\n        if(!mov.release_date){\n          mov.release_date = Date.parse(res.release_date);\n        }\n        if(!mov.year){\n          mov.year = res.Year;\n        }\n        mov.info = res;\n        Movies.update(mid, mov);\n      }));\n    },\n    updateTrailer: function (mid, name, year) {\n      movieTrailer(name, year, true, Meteor.bindEnvironment(function (err, res){\n        Meteor.call('queueDone', 'updateTrailer');\n        if(err){\n          broadcast(name + ': ' + err);\n          return false;\n        }\n        Movies.update(mid, { $set: {trailer: res}});\n      }));\n    },\n    updateRandom: function () {\n      var seeds = Movies.find({}, {fields: {'seed':1}});\n      seeds.forEach(function(seed){\n        Movies.update(seed._id, {$set: {'seed': Math.random()}});\n      });\n    },\n    queueIt: function (job, mid, name, year) {\n      if(api_current >= settings.max_connections){\n        // too many concurrent connections \n        Meteor.setTimeout(function() {\n          Meteor.call('queueIt', job, mid, name, year, function (err, res) {\n            if(err){\n              broadcast('Cinematic/queueIt: ' + err);\n            }\n          });\n        }, settings.retry_delay);\n      } else { \n        api_current += 1;\n        Meteor.call(job, mid, name, year, function (err, res) {\n          if(err){\n            broadcast('Cinematic/queueIt: ' + err);\n          } \n        });\n      }\n    },\n    queueDone: function (job) {\n      api_current -= 1;\n      api_queue -= 1;\n      // update loading percent every set\n      if(api_queue === 0) {\n        State.update(\"0\", {$set: {loading: 0}});\n        if(settings.cache){\n          Meteor.call('cacheMovies');\n        }\n      } else if(api_queue % settings.max_connections === 0) {\n        State.update(\"0\", {$set: {loading: Math.round((api_queue/api_total)*100)}});\n      }\n    },\n    reset: function () {\n      broadcast('Cinematic: Resetting server...');\n      State.remove({});\n      Recent.remove({});\n      Watched.remove({});\n      Genres.remove({});\n      Movies.remove({});\n      MovieCache.remove({});\n\n      // set default path\n      var dir = Meteor.call('findMovieDir');\n\n      var time = epoch();\n      var sid = State.insert({_id: '0', path: dir, cwd: process.env.PWD});\n\n      // grab genre list\n      Meteor.call('updateGenres');\n\n      // initial update\n      Meteor.call('updatePath', dir);\n    }\n  });\n\n} // end Meteor.isServer\n\n\n/*\n * UTILITIES\n */\n\n// safe console.log which outputs in the called context - client/server\nvar broadcast = function (msg) {\n  Log.insert({time: epoch(), msg: msg});\n  if (typeof console !== 'undefined')\n    console.log(msg);\n}\n\nvar epoch = function () {\n  var d = new Date();\n  return d.getTime() / 1000;\n}"]}